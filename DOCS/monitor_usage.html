<!doctype html>
<html>
<head>
  <!-- SPDX-License-Identifier: MIT -->
  <!-- Copyright (c) 2026 95west.us -->
  <!-- See LICENSE for full license text. -->
  <meta charset="utf-8" />
  <title>bso2 Monitor Usage</title>
  <style>
    body { font-family: Consolas, "Courier New", monospace; color: #111; margin: 32px; line-height: 1.35; font-size: 12px; }
    h1, h2, h3 { margin: 0 0 8px 0; }
    h1 { font-size: 24px; }
    h2 { font-size: 17px; margin-top: 20px; }
    h3 { font-size: 14px; margin-top: 16px; }
    p { margin: 6px 0; }
    .meta { color: #444; margin-bottom: 16px; }
    table { width: 100%; border-collapse: collapse; margin: 8px 0 16px 0; table-layout: fixed; }
    th, td { border: 1px solid #999; padding: 6px 8px; vertical-align: top; word-wrap: break-word; }
    th { background: #eee; text-align: left; }
    code { background: #f4f4f4; padding: 1px 3px; }
    .mono { white-space: pre; }
  </style>
</head>
<body>
  <h1>bso2 Monitor Reference</h1>
  <div class="meta">Target: W65C02EDU | Source: <code>SRC/bso2.asm</code> | Generated: 2026-02-14</div>

  <h2>0) Naming</h2>
  <p><code>bso2</code> is the preferred written form in this manual.</p>
  <p>It is intentionally dual-meaning and retro-styled:</p>
  <ul>
    <li><code>b</code> = Basic</li>
    <li><code>s</code> = System</li>
    <li><code>0</code> = Operations (also read as letter <code>O</code>)</li>
    <li><code>2</code> = <code>/2</code> and 6502 lineage</li>
  </ul>
  <p>Stylized-glyph note: <code>6</code> can stand in for lowercase <code>b</code>, and <code>5</code> can stand in for lowercase <code>s</code>.</p>
  <p>That makes <code>6502</code> a visual shorthand for <code>bso2</code> (<code>6</code>=<code>b</code>, <code>5</code>=<code>s</code>, <code>0</code>=<code>o</code>, <code>2</code>=<code>/2</code>).</p>
  <p>Expanded meaning: <code>Basic System Operations/2</code>.</p>

  <h2>1) Startup / Prompt Behavior</h2>
  <p>On reset with valid reset cookie, boot choices are <code>C/W/M</code>:</p>
  <p class="mono">C = clear RAM (confirm Y/N)
W = warm start
M = enter monitor</p>
  <p>After clear/startup, the sign-on banner (<code>BSO2_INIT</code>) is printed:</p>
  <p class="mono">     **** basic system operations/2 ****
     ****       b s o / 2  v0 . 9   ****
     ****         6 5 0 2           ****</p>
  <p>Monitor prompt is a single <code>-</code> character on a new line.</p>

  <h2>2) Command Summary</h2>
  <table>
    <tr><th style="width:15%">Cmd</th><th style="width:30%">Syntax</th><th style="width:35%">Behavior / Output</th><th style="width:20%">Flags / Notes</th></tr>
    <tr><td><code>?</code></td><td><code>?</code></td><td>Short help line.</td><td>Quick command list only.</td></tr>
    <tr><td><code>H</code></td><td><code>H</code></td><td>Full multi-line help.</td><td>Includes interactive caveats.</td></tr>
    <tr><td><code>Z</code></td><td><code>Z</code></td><td>Clear RAM after Y/N confirmation.</td><td>Zeroes <code>$0200-$7EFF</code>. Does not zero <code>$0000-$01FF</code> (ZP/stack) or <code>$7F00-$7FFF</code> (I/O area).</td></tr>
    <tr><td><code>W</code></td><td><code>W</code></td><td>Warm start back into monitor.</td><td>No args.</td></tr>
    <tr><td><code>D</code></td><td><code>D [START [END]]</code></td><td>Hex+ASCII dump. <code>END</code> is inclusive.</td><td><code>D</code> alone repeats last span from next address. Hex/ASCII fields show an 8+8 split.</td></tr>
    <tr><td><code>U</code></td><td><code>U START END</code></td><td>Disassemble as 65C02 mnemonics and operands.</td><td><code>END</code> is inclusive. Emits <code>ADDR: MNM OPERAND</code>.</td></tr>
    <tr><td><code>A</code></td><td><code>A START [INSN]</code></td><td>Tiny 65C02 assembler, interactive at next address.</td><td>Example: <code>A 1000 LDA #FF</code> then prompt <code>A 1002:</code>. <code>.</code> exits. No labels/forward refs. Relative branches accept absolute hex targets and are range-checked. Explicit accumulator form like <code>INC A</code> is supported.</td></tr>
    <tr><td><code>X</code></td><td><code>X START</code></td><td>Execute from absolute address.</td><td>Transfers control via RTS trampoline. NMI while running under <code>X</code> breaks back to monitor; target <code>RTS</code> also returns to monitor.</td></tr>
    <tr><td><code>R</code></td><td><code>R [A=HH] [X=HH] [Y=HH]</code></td><td>Resume last debug context.</td><td>Restores <code>A/X/Y/P/SP/PC</code> from latest debug snapshot and resumes via <code>RTI</code>. Optional <code>A/X/Y</code> overrides are applied first. Up-arrow repeat is useful for single-step resume loops.</td></tr>
    <tr><td><code>N</code></td><td><code>N</code></td><td>Run to next sequential instruction.</td><td>Implements next-stop by patching a temporary <code>BRK</code> at <code>PC+len(opcode)</code>. RAM only; ROM/I/O patch targets are rejected. Debug output restores and displays the original stepped-to instruction in <code>PREV:</code>.</td></tr>
    <tr><td><code>M</code></td><td><code>M [START [B0..B15]]</code></td><td>Modify/deposit memory. Inline deposit supports up to 16 bytes.</td><td>Interactive mode: <code>CR/LF = next</code>, <code>.</code> ends. CRLF pair counts as one next.</td></tr>
    <tr><td><code>F</code></td><td><code>F START END B0..B15</code></td><td>Fill inclusive range with repeating 1..16 byte pattern.</td><td>No interactive mode. Verifies each write.</td></tr>
    <tr><td><code>C</code></td><td><code>C SRC_START SRC_END DST_START</code></td><td>Copy inclusive source range to destination.</td><td>Overlap-safe (forward/backward selection). Verifies each write.</td></tr>
    <tr><td><code>!</code></td><td><code>!F ...</code>, <code>!M ...</code>, <code>!C ...</code>, <code>!A ...</code>, <code>!N</code></td><td>Force-prefix for protected commands.</td><td>Allows access to protected low RAM (<code>$0000-$03FF</code>).</td></tr>
    <tr><td><code>Q</code></td><td><code>Q</code></td><td>Enter WAI halt loop.</td><td>IRQ masked. Resume by NMI (or Reset). NMI latch returns cleanly to monitor.</td></tr>
    <tr><td><code>V</code></td><td><code>V</code></td><td>Show vector jump chains.</td><td>Displays HW vector to final code path.</td></tr>
  </table>

  <h2>3) Interactive Caveats</h2>
  <ul>
    <li><code>M</code> interactive: two hex digits are required per byte write (00..FF).</li>
    <li><code>A</code> interactive: type one mnemonic/operand per prompt, <code>.</code> exits assembler mode.</li>
    <li><code>.</code> exits interactive modify and retains next-address state for subsequent <code>M</code>.</li>
    <li><code>CR</code> or lone <code>LF</code> advances to next address.</li>
    <li><code>CRLF</code> pair is consumed as a single next-step.</li>
    <li><code>F</code> does not support interactive mode.</li>
    <li>At an empty monitor prompt, <code>Up Arrow</code> (<code>ESC [ A</code>) repeats and executes the previous command.</li>
    <li><code>F/M/C/A/N</code> block access to <code>$0000-$03FF</code> unless prefixed with <code>!</code>. <code>D</code> is always allowed.</li>
  </ul>

  <h2>4) Verify / Error Outputs</h2>
  <table>
    <tr><th style="width:28%">Operation</th><th style="width:72%">Message / Behavior</th></tr>
    <tr><td>Modify verify fail</td><td><code>M VERIFY FAILED AT ADDR </code> + failing address.</td></tr>
    <tr><td>Fill verify fail</td><td><code>F VERIFY FAILED AT ADDR </code> + failing address.</td></tr>
    <tr><td>Copy verify fail</td><td><code>C VERIFY FAILED AT ADDR </code> + failing address.</td></tr>
    <tr><td>Dump range error</td><td><code>D RANGE ERROR</code>.</td></tr>
    <tr><td>Unassemble range error</td><td><code>U RANGE ERROR</code>.</td></tr>
    <tr><td>Assembler branch range error</td><td><code>A BRANCH RANGE ERROR</code>.</td></tr>
    <tr><td>BRK debug context</td><td>Printed as three lines: <code>PREV:</code> (instruction at BRK opcode), <code>TRAP:</code> (register/status line), then <code>NEXT:</code> (instruction at resume PC). For <code>N</code>-generated temporary breaks, <code>PREV:</code> shows the restored original instruction.</td></tr>
    <tr><td>Bad syntax</td><td>Per-command usage lines (e.g. <code>USAGE: M [START [B0..B15]]</code>).</td></tr>
  </table>

  <h2>5) API Reference (Macros and Functions)</h2>
  <p>Use this section when calling monitor functionality from your own assembly code.</p>

  <h3>5.1) Macro Reference (<code>macros.inc</code>)</h3>
  <table>
    <tr><th style="width:18%">Macro</th><th style="width:30%">Parameters</th><th style="width:52%">Behavior / Notes</th></tr>
    <tr><td><code>PUSH</code></td><td><code>PUSH p1 [,p2] [,p3] [,p4]</code></td><td>Pushes listed registers in given order. Supported tokens: <code>A/X/Y/P</code> (case-insensitive).</td></tr>
    <tr><td><code>PULL</code></td><td><code>PULL p1 [,p2] [,p3] [,p4]</code></td><td>Pops listed registers in given order. Keep ordering compatible with prior <code>PUSH</code>.</td></tr>
    <tr><td><code>REPEAT</code></td><td><code>REPEAT Routine, Count</code></td><td>Calls <code>JSR Routine</code> repeatedly <code>Count</code> times. Preserves <code>X</code> via push/pull.</td></tr>
    <tr><td><code>PRT_CSTRING</code></td><td><code>PRT_CSTRING Label</code></td><td>Prints null-terminated string at <code>Label</code> via <code>PRT_C_STRING</code>.</td></tr>
    <tr><td><code>DUMP</code></td><td><code>DUMP Start, EndExclusive</code></td><td>Convenience wrapper for <code>MEM_DUMP</code> with explicit exclusive end.</td></tr>
    <tr><td><code>FILL</code></td><td><code>FILL Start, EndInclusive, B0 [,B1] [,B2] [,B3] [,B4]</code></td><td>Loads pattern bytes (1..5) and calls <code>MEM_FILL_PATTERN</code>. End is inclusive in macro syntax.</td></tr>
    <tr><td><code>COPY</code></td><td><code>COPY SrcStart, SrcEndInclusive, DstStart</code></td><td>Calls overlap-safe <code>MEM_COPY_RANGE</code>. Source end is inclusive in macro syntax.</td></tr>
    <tr><td><code>COPY_BLOCK</code></td><td><code>COPY_BLOCK SrcStart, Length, DstStart</code></td><td>Compatibility wrapper that expands to <code>COPY SrcStart,(SrcStart+Length-1),DstStart</code>.</td></tr>
    <tr><td><code>CMP_CSTRING</code></td><td><code>CMP_CSTRING AddrA, AddrB</code></td><td>Wrapper for project-specific string compare symbols/routine (<code>STRCMP_PTR_*</code>, <code>STR_COMPARE</code>). Use only when those symbols are provided by your build.</td></tr>
  </table>

  <h3>5.2) Callable Function Reference</h3>
  <p>Practical entry points for extensions and integration.</p>
  <table>
    <tr><th style="width:17%">Routine</th><th style="width:31%">Input</th><th style="width:20%">Output</th><th style="width:16%">Flags</th><th style="width:16%">ZP / Memory Use</th></tr>
    <tr><td><code>INIT_SERIAL</code></td><td>None</td><td>UART initialized</td><td>Unchanged</td><td>None</td></tr>
    <tr><td><code>WRITE_BYTE</code></td><td><code>A</code>=char</td><td>Char sent to UART, LED updated</td><td>Unchanged</td><td>None</td></tr>
    <tr><td><code>READ_BYTE</code></td><td>None</td><td><code>A</code>=received char (ROM read)</td><td>ROM-defined</td><td>None</td></tr>
    <tr><td><code>CHECK_BYTE</code></td><td>None</td><td><code>A</code>=status</td><td><code>C=1</code> if RX empty</td><td>None</td></tr>
    <tr><td><code>RBUF_INIT</code></td><td>None</td><td>Input ring reset</td><td>Unchanged</td><td>Uses generic buffer descriptor core</td></tr>
    <tr><td><code>BUF_INIT</code></td><td>Active descriptor pointers set</td><td>Head/Tail/Count zeroed</td><td>Unchanged</td><td>Uses <code>BUF_*_PTR</code></td></tr>
    <tr><td><code>BUF_PUT_A</code></td><td><code>A</code>=byte</td><td>Byte queued</td><td><code>C=0</code> stored, <code>C=1</code> full</td><td>Uses <code>BUF_*_PTR</code>, <code>BUF_SIZE</code></td></tr>
    <tr><td><code>BUF_GET_A</code></td><td>None</td><td><code>A</code>=byte</td><td><code>C=0</code> byte, <code>C=1</code> empty</td><td>Uses <code>BUF_*_PTR</code>, <code>BUF_SIZE</code></td></tr>
    <tr><td><code>CMD_DISPATCH</code></td><td><code>A</code>=command letter</td><td>Handler called from table</td><td><code>C=0</code> handled, <code>C=1</code> unknown</td><td>Uses <code>CMD_TABLE</code>, <code>CMD_POST_ACTION</code></td></tr>
    <tr><td><code>MEM_DUMP</code></td><td><code>PTR_DUMP_CUR</code>=start (inc), <code>PTR_TEMP</code>=end (exc)</td><td>Formatted hex+ASCII dump with 8+8 separator</td><td>Unchanged</td><td>Uses <code>PTR_DUMP_CUR</code>, <code>PTR_DUMP_END</code>, <code>PTR_LEG</code>, <code>MEM_DUMP_CNT</code></td></tr>
    <tr><td><code>MEM_DISASM_65C02</code></td><td><code>PTR_DUMP_CUR</code>=start (inc), <code>PTR_TEMP</code>=end (inc)</td><td>65C02 disassembly output (<code>ADDR: MNM OPERAND</code>)</td><td>Unchanged</td><td>Uses <code>PTR_DUMP_CUR</code>, <code>PTR_DUMP_END</code>, <code>PTR_TEMP</code>, <code>PTR_LEG</code>, <code>DIS_*</code></td></tr>
    <tr><td><code>MEM_FILL_PATTERN</code></td><td><code>PTR_DUMP_CUR</code>=start (inc), <code>PTR_DUMP_END</code>=end (exc), <code>F_COUNT</code>=pattern length, <code>F_PATTERN</code>=pattern bytes</td><td>Fills range with repeating pattern</td><td><code>C=0</code> complete, <code>C=1</code> aborted (verify/protect)</td><td>Uses <code>PTR_DUMP_CUR</code>, <code>PTR_DUMP_END</code>, <code>F_COUNT</code>, <code>F_PATTERN</code>, <code>F_PAT_IDX</code></td></tr>
    <tr><td><code>MEM_COPY_RANGE</code></td><td><code>PTR_LEG</code>=src start (inc), <code>PTR_DUMP_END</code>=src end (exc), <code>PTR_TEMP</code>=dst start</td><td>Copies source to destination (overlap-safe)</td><td><code>C=0</code> complete, <code>C=1</code> aborted (verify/protect)</td><td>Uses <code>PTR_LEG</code>, <code>PTR_DUMP_CUR</code>, <code>PTR_DUMP_END</code>, <code>PTR_TEMP</code>, <code>CMD_PARSE_VAL</code></td></tr>
    <tr><td><code>CMD_DO_ASM</code></td><td><code>CMD_LINE</code>=<code>A START [INSN]</code></td><td>Interactive tiny assembler</td><td><code>.</code> exits</td><td>Uses <code>CMD_LINE</code>, <code>PTR_TEMP</code>, opcode tables, and <code>ASM_*</code>/<code>DIS_*</code> scratch</td></tr>
  </table>

  <h2>6) Parser and Buffer Limits</h2>
  <ul>
    <li><code>CMD_MAX_LEN = 31</code> characters (excluding null terminator).</li>
    <li><code>RBUF_SIZE = 32</code> bytes.</li>
    <li>One-command history is kept for up-arrow repeat (<code>CMD_LAST_LINE</code>).</li>
    <li>Hex token parser accepts 1..4 hex digits, optional <code>$</code> prefix.</li>
    <li><code>M</code> and <code>F</code> inline byte lists: max 16 bytes each.</li>
    <li><code>!</code> is consumed as a command prefix, then normal parsing continues.</li>
  </ul>

  <h2>7) Memory Usage</h2>
  <h3>Build Section Usage (current)</h3>
  <table>
    <tr><th>Section</th><th>ORG</th><th>Size (hex)</th><th>Size (dec)</th></tr>
    <tr><td>PAGE0</td><td><code>$0040</code></td><td><code>$4A</code></td><td>74</td></tr>
    <tr><td>CODE</td><td><code>$8000</code></td><td><code>$1A22</code></td><td>6690</td></tr>
    <tr><td>KDATA</td><td><code>$E000</code></td><td><code>$B25</code></td><td>2853</td></tr>
    <tr><td>UDATA</td><td><code>$0200</code></td><td><code>$7A</code></td><td>122</td></tr>
    <tr><td>Total</td><td>-</td><td><code>$260B</code></td><td>9739</td></tr>
  </table>

  <h3>RAM Layout Highlights</h3>
  <ul>
    <li>PAGE0 starts at <code>$0040</code>. Includes parser state, dump state, debug snapshot, vector hooks, and active buffer descriptor pointers.</li>
    <li>UDATA starts at <code>$0200</code>:</li>
  </ul>
  <p class="mono">RBUF_DATA    32 bytes
CMD_LINE     32 bytes (31 + NUL)
CMD_LAST_LINE 32 bytes (31 + NUL)
RESET_COOKIE  4 bytes
F_PATTERN    16 bytes
DBG_TAG_BUF   6 bytes</p>

  <h2>8) Notes for Integrators</h2>
  <ul>
    <li>Command parser uppercases incoming command bytes before parse/dispatch.</li>
    <li>Command execution is table-driven via <code>CMD_TABLE</code>.</li>
    <li>Input buffering now uses a generic descriptor-based core bound to the ring buffer.</li>
    <li><code>Q</code> path relies on NMI latch (<code>SYSF_NMI_FLAG_M</code>) and then re-enters monitor cleanly.</li>
  </ul>

  <h2>9) Legal Notice</h2>
  <ul>
    <li><code>WDC</code>, <code>W65C02</code>, and <code>W65C02EDU</code> are names associated with Western Design Center, Inc.</li>
    <li>This project is independent and is not affiliated with or endorsed by Western Design Center, Inc.</li>
    <li>This repository does not redistribute WDC tool binaries or WDC ROM images.</li>
    <li>Any third-party source code or text should be included only under its original license terms.</li>
  </ul>
</body>
</html>


